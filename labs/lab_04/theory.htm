<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../style.css">
</head>

<body>
<a name="top"></a>
<h1><b>4. Цикли з розгалуженням</b>
</h1>
<em>Мета  роботи:</em>
<ol>
  <li>
    Вивчити особливості циклічних обчислювальних процесів з розгалуженнями  
  </li>
  <li>
    Опанувати технологію рекурентних обчислень
  </li>
  <li>
    Навчитися розробляти алгоритми та програми розвинення функцій у ряди
  </li>
</ol>
<h2>4.1. Теоретичні відомості</h2>
<h3><span style="color: #00C">4.1.1. Рекурентні співвідношення</span><br>
</h3>
<p>Формула, що виражає член  послідовності через один або декілька попередніх, називається <em>рекурентним співвідношенням</em>. 
Послідовність, члени якої задовольняють деякому рекурентному  співвідношенню, називається рекурентною.<br>
У загальному випадку  рекурентне співвідношення визначає залежність члена&nbsp; послідовності <img src="pictures/t1.gif" width="26" height="14" align="baseline"> від <em>k</em> попередніх: 
<img src="pictures/t2.gif" width="128" height="14" />. <br>
Наближене значення суми  ряду можна отримати або обмежуючись сумою перших <em>n </em>його членів, або обчислюючи суму з наперед заданою точністю. 
Формула загального члена даного ряду є достатньо  простою, але використовувати її не раціонально, оскільки для кожного члена ряду  треба обчислювати степінь і факторіал. 
Набагато вищої ефективності можна  досягти, обчислюючи член ряду за допомогою рекурентного співвідношення. Найпростішими  прикладами рекурентних послідовностей є арифметична та 
геометрична прогресії,  елементи яких пов&rsquo;язані з попередніми елементами співвідношеннями <img src="pictures/t3.gif" width="88" height="13" />&nbsp; та <img src="pictures/t4.gif" width="85" height="10" />, 
де <em>d</em> та <em>q</em> &mdash; деякі сталі  величини, <em><img src="pictures/t5.gif" width="14" height="9" />&ndash;</em> значення  елемента ряду на кроці <em>n.</em></p>
Із  заданою точністю може бути обчислена сума лише збіжного ряду, а довільний  степеневий ряд має певну область збіжності (можливо, порожню), тобто збігається  не за всіх, а лише за деяких 
значень <em>x</em> (ряд, що розглядається нами як приклад, збігається для будь-якого дійсного <em>x</em>). По-друге, простий спосіб перевірки  точності часткової суми ряду існує не для 
всіх рядів. Такий спосіб існує,  зокрема, для знакопереміжних рядів, абсолютні величини членів яких, починаючи з  деякого номера, утворюють монотонно спадну послідовність. Для таких 
рядів сума  всіх членів, починаючи від (<em>n</em>+1)-го,  є меншою за модулем від <em>n</em>-го
 <p><img src="pictures/t6.gif" width="89" height="46" /><br>
  <br>
</p>
<h3 style="color: #00C">4.1.2. Функції користувача</h3>
<p>Функція користувача  містить оператори, що логічно не залежать від іншого коду програми, і може  викликатися з будь-якого місця програми довільну кількість разів. 
Формат  функції визначає її заголовок та тіло, яке містить оператори відповідно до  алгоритму. Визначення функції передбачає наявність заголовка та тіла. Функцію  без заданого 
прототипу визначають перед функціями, які її викликають, а ту, що  має прототип, можна визначати в будь-якому місці програми. Функція має повернути  тільки одне визначене 
значення до основної програми. Тип значення, що  повертається, визначається у заголовку функції. <br>
Оголошення функції  (прототип) задається у вигляді:</p>
<p><span class="light">тип_значення_що_повертається</span> ім'я_функції (<span class="light">тип_параметра</span> ім'я_параметра1, <span class="light">тип_параметра</span> ім'я_параметра2);</p>

<p>Визначення функції  містить її код виконання. Заголовки функції при оголошенні та визначенні  збігаються. Не ставиться символ ; наприкінці заголовка. Для повернення значення  з функції в тілі функції необхідно мати оператор повернення return. <br>
Приклад визначення  найбільшого з двох чисел: </p>
<p><span class="light">float</span> max(<span class="light">float</span> a,<span class="light">float</span> b)  //заголовок функції з параметрами <br>
  {<br>
  <span class="light">float</span> m; &nbsp;&nbsp;&nbsp;//найбільше значення <br>
  m =(a&gt;b)?a:b; //умовний вираз<br>
  <span class="light">return</span> m;&nbsp;&nbsp;&nbsp; //значення, що визначилося та повертається <br>
  } <br>
Функцію можна оголосити у  вигляді:&nbsp;</p>
<p>&nbsp;<span class="light">void</span> ім'я_функції(<span class="light">void</span>);</p>
<p>Тип <span class="light">void</span> значення, що повертається, означає, що така функція не повертає ніякого  значення. Оператор <span class="light">return</span> не потрібний. 
Тип <span class="light">void</span> у списку параметрів  означає, що функція не має параметрів.<br>
Функція виконує  закодовані в ній дії за допомогою оператора виклику. У процесі визначення  функції у заголовку описуються формальні параметри, які замінюються на  аргументи 
під час виклику функції. Якщо функція не повертає значення у точку  виклику,&nbsp; формат оператора її виклику має  такий вигляд:&nbsp;&nbsp;</p>
<p>&nbsp;ім'я_функції(аргументи);</p>
<p>Якщо функція повертає  будь-яке значення, то під час її виклику це значення треба присвоїти змінній  відповідного типу. Формат оператора виклику такий:&nbsp; &nbsp; </p>
<p>&nbsp;ім'я_змінної =  ім'я_функції(аргументи);<br>
  </p>
<p><strong>Приклад циклу для обчислення значення функції <em>sin(x)</em> </strong> за допомогою степеневого ряду з використання рекурентних співідношень.</p>
<p><img src="pictures/exampleSinx.png"</p><br> 
<p>Для виконання  лабораторної роботи необхідно використовувати ряди, які представляють функції  (табл. 4.1).</p>

<p><em>Таблиця 4.1</em> <strong>Рекурентні  формули розвинення функцій у ряди</strong><br>
</p>
<table border="1">
  <tr>
    <td width="89"><strong>Функції</strong></td>
    <td width="400"><strong>Розвинення у ряд Маклорена (або Тейлора)</strong></td>
  </tr>
  <tr>
    <td>sin(x)</td>
    <td><img src="pictures/t10.gif" width="169" height="13" /></td>
  </tr>
  <tr>
    <td>cos(x)</td>
    <td><img src="pictures/t11.gif" width="174" height="13" /></td>
  </tr>
 <tr>
    <td>arcsin(x)</td>
    <td><img src="pictures/t18.gif" width="350" height="35" /></td>
  </tr>
  <tr>
    <td>arctg(x)</td>
    <td><img src="pictures/t12.gif" width="153" height="13" /></td>
  </tr>
  <tr>
    <td>ln(x)</td>
    <td><img src="pictures/t13.gif" width="244" height="16" /></td>
  </tr>
  <tr>
    <td><img src="pictures/t7.gif" width="13" height="10" /></td>
    <td><img src="pictures/t14.gif" width="196" height="13" /></td>
  </tr>
  <tr>
    <td><img src="pictures/t8.gif" width="17" height="10" /></td>
    <td><img src="pictures/t15.gif" width="202" height="13" /></td>
  </tr>
  <tr>
    <td>sh(x)</td>
    <td><img src="pictures/t16.gif" width="176" height="13" /></td>
  </tr>
<tr>
    <td>ch(x)</td>
    <td><img src="pictures/t19.gif" width="176" height="13" /></td>
  </tr>
  <tr>
    <td><img src="pictures/t9.gif" width="22" height="20" /></td>
    <td><img src="pictures/t17.gif" width="258" height="14" /></td>
  </tr>
</table>

<p><a href="#top">Вверх</a></p>
</body>
</html>